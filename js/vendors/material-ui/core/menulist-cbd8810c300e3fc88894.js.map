{"version":3,"sources":["webpack:///./node_modules/@material-ui/core/esm/MenuList/index.js","webpack:///./node_modules/@material-ui/core/esm/MenuList/MenuList.js"],"names":["nextItem","list","item","disableListWrap","firstChild","nextElementSibling","previousItem","lastChild","previousElementSibling","textCriteriaMatches","nextFocus","textCriteria","undefined","text","innerText","textContent","trim","toLowerCase","length","repeating","keys","indexOf","join","moveFocus","currentFocus","disabledItemsFocusable","traversalFunction","wrappedOnce","nextFocusDisabled","disabled","getAttribute","hasAttribute","focus","useEnhancedEffect","window","React","useEffect","useLayoutEffect","forwardRef","props","ref","actions","_props$autoFocus","autoFocus","_props$autoFocusItem","autoFocusItem","children","className","_props$disabledItemsF","_props$disableListWra","onKeyDown","_props$variant","variant","other","listRef","useRef","textCriteriaRef","previousKeyMatched","lastTime","current","useImperativeHandle","adjustStyleForScrollbar","containerElement","theme","noExplicitWidth","style","width","clientHeight","scrollbarSize","concat","direction","handleOwnRef","useCallback","instance","ReactDOM","findDOMNode","handleRef","activeItemIndex","Children","forEach","child","index","isValidElement","selected","items","map","newChildProps","tabIndex","cloneElement","createElement","List","role","event","key","activeElement","preventDefault","criteria","lowerKey","currTime","performance","now","push","keepFocusOnCurrent"],"mappings":"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","file":"js/vendors/material-ui/core/menulist-cbd8810c300e3fc88894.js","sourcesContent":["export { default } from './MenuList';","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport * as ReactDOM from 'react-dom';\nimport ownerDocument from '../utils/ownerDocument';\nimport List from '../List';\nimport getScrollbarSize from '../utils/getScrollbarSize';\nimport useForkRef from '../utils/useForkRef';\n\nfunction nextItem(list, item, disableListWrap) {\n  if (list === item) {\n    return list.firstChild;\n  }\n\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n\n  return disableListWrap ? null : list.firstChild;\n}\n\nfunction previousItem(list, item, disableListWrap) {\n  if (list === item) {\n    return disableListWrap ? list.firstChild : list.lastChild;\n  }\n\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n\n  return disableListWrap ? null : list.lastChild;\n}\n\nfunction textCriteriaMatches(nextFocus, textCriteria) {\n  if (textCriteria === undefined) {\n    return true;\n  }\n\n  var text = nextFocus.innerText;\n\n  if (text === undefined) {\n    // jsdom doesn't support innerText\n    text = nextFocus.textContent;\n  }\n\n  text = text.trim().toLowerCase();\n\n  if (text.length === 0) {\n    return false;\n  }\n\n  if (textCriteria.repeating) {\n    return text[0] === textCriteria.keys[0];\n  }\n\n  return text.indexOf(textCriteria.keys.join('')) === 0;\n}\n\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n  var wrappedOnce = false;\n  var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\n\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return;\n      }\n\n      wrappedOnce = true;\n    } // Same logic as useAutocomplete.js\n\n\n    var nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\n    } else {\n      nextFocus.focus();\n      return;\n    }\n  }\n}\n\nvar useEnhancedEffect = typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;\n/**\n * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.\n * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you\n * use it separately you need to move focus into the component manually. Once\n * the focus is placed inside the component it is fully keyboard accessible.\n */\n\nvar MenuList = React.forwardRef(function MenuList(props, ref) {\n  var actions = props.actions,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      _props$autoFocusItem = props.autoFocusItem,\n      autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem,\n      children = props.children,\n      className = props.className,\n      _props$disabledItemsF = props.disabledItemsFocusable,\n      disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,\n      _props$disableListWra = props.disableListWrap,\n      disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,\n      onKeyDown = props.onKeyDown,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,\n      other = _objectWithoutProperties(props, [\"actions\", \"autoFocus\", \"autoFocusItem\", \"children\", \"className\", \"disabledItemsFocusable\", \"disableListWrap\", \"onKeyDown\", \"variant\"]);\n\n  var listRef = React.useRef(null);\n  var textCriteriaRef = React.useRef({\n    keys: [],\n    repeating: true,\n    previousKeyMatched: true,\n    lastTime: null\n  });\n  useEnhancedEffect(function () {\n    if (autoFocus) {\n      listRef.current.focus();\n    }\n  }, [autoFocus]);\n  React.useImperativeHandle(actions, function () {\n    return {\n      adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {\n        // Let's ignore that piece of logic if users are already overriding the width\n        // of the menu.\n        var noExplicitWidth = !listRef.current.style.width;\n\n        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\n          var scrollbarSize = \"\".concat(getScrollbarSize(true), \"px\");\n          listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\n          listRef.current.style.width = \"calc(100% + \".concat(scrollbarSize, \")\");\n        }\n\n        return listRef.current;\n      }\n    };\n  }, []);\n\n  var handleKeyDown = function handleKeyDown(event) {\n    var list = listRef.current;\n    var key = event.key;\n    /**\n     * @type {Element} - will always be defined since we are in a keydown handler\n     * attached to an element. A keydown event is either dispatched to the activeElement\n     * or document.body or document.documentElement. Only the first case will\n     * trigger this specific handler.\n     */\n\n    var currentFocus = ownerDocument(list).activeElement;\n\n    if (key === 'ArrowDown') {\n      // Prevent scroll of the page\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'ArrowUp') {\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key === 'Home') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'End') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key.length === 1) {\n      var criteria = textCriteriaRef.current;\n      var lowerKey = key.toLowerCase();\n      var currTime = performance.now();\n\n      if (criteria.keys.length > 0) {\n        // Reset\n        if (currTime - criteria.lastTime > 500) {\n          criteria.keys = [];\n          criteria.repeating = true;\n          criteria.previousKeyMatched = true;\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\n          criteria.repeating = false;\n        }\n      }\n\n      criteria.lastTime = currTime;\n      criteria.keys.push(lowerKey);\n      var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\n        event.preventDefault();\n      } else {\n        criteria.previousKeyMatched = false;\n      }\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  var handleOwnRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    listRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  var handleRef = useForkRef(handleOwnRef, ref);\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n\n  var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n\n  React.Children.forEach(children, function (child, index) {\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"Material-UI: the Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n  var items = React.Children.map(children, function (child, index) {\n    if (index === activeItemIndex) {\n      var newChildProps = {};\n\n      if (autoFocusItem) {\n        newChildProps.autoFocus = true;\n      }\n\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\n        newChildProps.tabIndex = 0;\n      }\n\n      return React.cloneElement(child, newChildProps);\n    }\n\n    return child;\n  });\n  return /*#__PURE__*/React.createElement(List, _extends({\n    role: \"menu\",\n    ref: handleRef,\n    className: className,\n    onKeyDown: handleKeyDown,\n    tabIndex: autoFocus ? 0 : -1\n  }, other), items);\n});\nprocess.env.NODE_ENV !== \"production\" ? MenuList.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * If `true`, will focus the `[role=\"menu\"]` container and move into tab order.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * If `true`, will focus the first menuitem if `variant=\"menu\"` or selected item\n   * if `variant=\"selectedMenu\"`.\n   */\n  autoFocusItem: PropTypes.bool,\n\n  /**\n   * MenuList contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * If `true`, will allow focus on disabled items.\n   */\n  disabledItemsFocusable: PropTypes.bool,\n\n  /**\n   * If `true`, the menu items will not wrap focus.\n   */\n  disableListWrap: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu'])\n} : void 0;\nexport default MenuList;"],"sourceRoot":""}