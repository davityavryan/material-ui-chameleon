{"version":3,"sources":["webpack:///./node_modules/@material-ui/core/esm/TextareaAutosize/index.js","webpack:///./node_modules/@material-ui/core/esm/TextareaAutosize/TextareaAutosize.js"],"names":["getStyleValue","computedStyle","property","parseInt","useEnhancedEffect","window","React","useLayoutEffect","useEffect","styles","visibility","position","overflow","height","top","left","transform","forwardRef","props","ref","onChange","rows","rowsMax","_props$rowsMin","rowsMin","rowsMinProp","style","value","other","isControlled","useRef","current","inputRef","handleRef","shadowRef","renders","_React$useState","useState","state","setState","syncHeight","useCallback","input","getComputedStyle","inputShallow","width","placeholder","boxSizing","padding","border","innerHeight","scrollHeight","singleRowHeight","outerHeight","Math","max","Number","min","outerHeightStyle","abs","prevState","handleResize","addEventListener","clear","removeEventListener","createElement","Fragment","event","className","readOnly","tabIndex"],"mappings":"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","file":"js/vendors/material-ui/core/textareaautosize-6ae66a19994b663af109.js","sourcesContent":["export { default } from './TextareaAutosize';","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport debounce from '../utils/debounce';\nimport useForkRef from '../utils/useForkRef';\n\nfunction getStyleValue(computedStyle, property) {\n  return parseInt(computedStyle[property], 10) || 0;\n}\n\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar styles = {\n  /* Styles applied to the shadow textarea element. */\n  shadow: {\n    // Visibility needed to hide the extra text area on iPads\n    visibility: 'hidden',\n    // Remove from the content flow\n    position: 'absolute',\n    // Ignore the scrollbar width\n    overflow: 'hidden',\n    height: 0,\n    top: 0,\n    left: 0,\n    // Create a new layer, increase the isolation of the computed values\n    transform: 'translateZ(0)'\n  }\n};\nvar TextareaAutosize = React.forwardRef(function TextareaAutosize(props, ref) {\n  var onChange = props.onChange,\n      rows = props.rows,\n      rowsMax = props.rowsMax,\n      _props$rowsMin = props.rowsMin,\n      rowsMinProp = _props$rowsMin === void 0 ? 1 : _props$rowsMin,\n      style = props.style,\n      value = props.value,\n      other = _objectWithoutProperties(props, [\"onChange\", \"rows\", \"rowsMax\", \"rowsMin\", \"style\", \"value\"]);\n\n  var rowsMin = rows || rowsMinProp;\n\n  var _React$useRef = React.useRef(value != null),\n      isControlled = _React$useRef.current;\n\n  var inputRef = React.useRef(null);\n  var handleRef = useForkRef(ref, inputRef);\n  var shadowRef = React.useRef(null);\n  var renders = React.useRef(0);\n\n  var _React$useState = React.useState({}),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var syncHeight = React.useCallback(function () {\n    var input = inputRef.current;\n    var computedStyle = window.getComputedStyle(input);\n    var inputShallow = shadowRef.current;\n    inputShallow.style.width = computedStyle.width;\n    inputShallow.value = input.value || props.placeholder || 'x';\n    var boxSizing = computedStyle['box-sizing'];\n    var padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');\n    var border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width'); // The height of the inner content\n\n    var innerHeight = inputShallow.scrollHeight - padding; // Measure height of a textarea with a single row\n\n    inputShallow.value = 'x';\n    var singleRowHeight = inputShallow.scrollHeight - padding; // The height of the outer content\n\n    var outerHeight = innerHeight;\n\n    if (rowsMin) {\n      outerHeight = Math.max(Number(rowsMin) * singleRowHeight, outerHeight);\n    }\n\n    if (rowsMax) {\n      outerHeight = Math.min(Number(rowsMax) * singleRowHeight, outerHeight);\n    }\n\n    outerHeight = Math.max(outerHeight, singleRowHeight); // Take the box sizing into account for applying this value as a style.\n\n    var outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);\n    var overflow = Math.abs(outerHeight - innerHeight) <= 1;\n    setState(function (prevState) {\n      // Need a large enough difference to update the height.\n      // This prevents infinite rendering loop.\n      if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {\n        renders.current += 1;\n        return {\n          overflow: overflow,\n          outerHeightStyle: outerHeightStyle\n        };\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (renders.current === 20) {\n          console.error(['Material-UI: too many re-renders. The layout is unstable.', 'TextareaAutosize limits the number of renders to prevent an infinite loop.'].join('\\n'));\n        }\n      }\n\n      return prevState;\n    });\n  }, [rowsMax, rowsMin, props.placeholder]);\n  React.useEffect(function () {\n    var handleResize = debounce(function () {\n      renders.current = 0;\n      syncHeight();\n    });\n    window.addEventListener('resize', handleResize);\n    return function () {\n      handleResize.clear();\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [syncHeight]);\n  useEnhancedEffect(function () {\n    syncHeight();\n  });\n  React.useEffect(function () {\n    renders.current = 0;\n  }, [value]);\n\n  var handleChange = function handleChange(event) {\n    renders.current = 0;\n\n    if (!isControlled) {\n      syncHeight();\n    }\n\n    if (onChange) {\n      onChange(event);\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"textarea\", _extends({\n    value: value,\n    onChange: handleChange,\n    ref: handleRef // Apply the rows prop to get a \"correct\" first SSR paint\n    ,\n    rows: rowsMin,\n    style: _extends({\n      height: state.outerHeightStyle,\n      // Need a large enough difference to allow scrolling.\n      // This prevents infinite rendering loop.\n      overflow: state.overflow ? 'hidden' : null\n    }, style)\n  }, other)), /*#__PURE__*/React.createElement(\"textarea\", {\n    \"aria-hidden\": true,\n    className: props.className,\n    readOnly: true,\n    ref: shadowRef,\n    tabIndex: -1,\n    style: _extends({}, styles.shadow, {}, style)\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? TextareaAutosize.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * @ignore\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * Use `rowsMin` instead. The prop will be removed in v5.\n   *\n   * @deprecated\n   */\n  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * Maximum number of rows to display.\n   */\n  rowsMax: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * Minimum number of rows to display.\n   */\n  rowsMin: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * @ignore\n   */\n  style: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  value: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.number, PropTypes.string])\n} : void 0;\nexport default TextareaAutosize;"],"sourceRoot":""}